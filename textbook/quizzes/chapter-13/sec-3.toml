[[questions]]

prompt = "Which of the following is/are the difference between inserting a node at the head and at the tail of a linked list?"

answer = [3]

distractors = [
    "Inserting at the head requires traversing the entire linked list, while inserting at the tail does not require any traversal.",
    "Inserting at the head changes the order of the existing elements, while inserting at the tail maintains the order.",
    "The order (traverse from the head to the tail) of the linked list is maintained when inserting at the head, while the order is not maintained when inserting at the tail.",
    "None of the above."
]

explainations = [
    "A is incorrect. Inserting at the head or tail of a linked list does not necessarily require traversing the entire list. Both operations can be performed in constant time if appropriate references/pointers are maintained.",
    "B is incorrect. Neither inserting at the head nor inserting at the tail changes the order of existing elements in a linked list. They only affect the position of the newly inserted node.",
    "C is incorrect. The order is maintained when inserting at the tail, but not when inserting at the head.",
    "D is correct."
]

[[questions]]

prompt = '''
Which of the following code can insert a node at the tail of a linked list?

Assume the following struct has been defined:
```
typedef struct node {
    int data;
    struct node *next;
} Node;

Node *createNode(int value) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    if (newNode == NULL) {
        return NULL;
    }
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}
```
'''

answer = [1, 2, 3]

distractors = [
'''
```
bool insertAtTail(Node **tailPtr, int value) {
    Node *temp = createNode(value);
    if (temp == NULL) {
        return false;
    }
    (*tailPtr)->next = temp;
    temp->next = *tailPtr;
    return true;
}

int main(void) {
    Node *head = createNode(1);
    Node *tail = head;

    insertAtTail(&tail, 2);
    insertAtTail(&tail, 3);

    return 0;
}
```
''',
'''
```
bool insertAtTail(Node **tailPtr, int value) {
    Node *temp = createNode(value);
    if (temp == NULL) {
        return false;
    }
    (*tailPtr)->next = temp;
    *tailPtr = temp;
    return true;
}

int main(void) {
    Node *head = createNode(1);
    Node *tail = head;

    insertAtTail(&tail, 2);
    insertAtTail(&tail, 3);

    return 0;
}
```
''',
'''
```
bool insertAtTail(Node *head, int value) {
    Node *temp = createNode(value);
    if (temp == NULL) {
        return false;
    }
    Node *cur = head;
    while (cur != NULL) {
        if (cur->next == NULL) {
            cur->next = temp;
            break;
        } else {
            cur = cur->next;
        }
    } 
    return true;
}

int main(void) {
    Node *head = createNode(1);

    insertAtTail(head, 2);
    insertAtTail(head, 3);

    return 0;
}
```
''',
'''
```
typedef struct list {
  Node* tail;
} LinkedList;

bool insertAtTail(LinkedList *list, int value) {
    Node *temp = createNode(value);
    if (temp == NULL) {
        return false;
    }
    list->tail->next = temp;
    list->tail = temp;
    return true;
}

int main(void) {
    Node *head = createNode(1);
    LinkedList list;
    list.tail = head;

    insertAtTail(&list, 2);
    insertAtTail(&list, 3);

    return 0;
}
```
'''
]

explainations = [
    "A is incorrect. The code incorrectly updates the tail pointer. The output of the code is a circular linked list.",
    "B is correct. The code inserts the node at the tail of the linked list by passing the tail pointer.",
    "C is correct. The code traverses the linked list to find the tail node, and then inserts the node at the tail.",
    "D is correct. The code create a new data structure to store the tail pointer, and then inserts the node at the tail."
]

[[questions]]

prompt = '''
Which of the following correctly traverse(s) and print(s) all elements of a linked list in order?

Assume the following struct has been defined:
```
typedef struct node {
    int data;
    struct node *next;
} Node;

Node *createNode(int value) {
    Node *newNode = (Node *)malloc(sizeof(Node));
    if (newNode == NULL) {
        return NULL;
    }
    newNode->data = value;
    newNode->next = NULL;
    return newNode;
}
```
'''

answer = [0, 2]

distractors = [
'''
```
int main(void) {
    Node *node1 = createNode(1);
    Node *node2 = createNode(2);
    Node *node3 = createNode(3);

    node1->next = node2;
    node2->next = node3;
    
    Node *cur = node1;
    while (cur != NULL) {
        printf("%d ", cur->data);
        cur = cur->next;
    } 

    return 0;
}
```
''',
'''
```
int main(void) {
    Node *node1 = createNode(1);
    Node *node2 = createNode(2);
    Node *node3 = createNode(3);

    node1->next = node2;
    node2->next = node3;
    
    Node *cur = node1;
    while (cur->next != NULL) {
        printf("%d ", cur->data);
        if (cur->next == NULL) {
            break;
        } else {
            cur = cur->next;
        }
    } 

    return 0;
}
```
''',
'''
```
int main(void) {
    Node *node1 = createNode(1);
    Node *node2 = createNode(2);
    Node *node3 = createNode(3);

    node1->next = node2;
    node2->next = node3;
    
    Node *cur = node1;
    do {
        if (cur != NULL) {
            printf("%d ", cur->data);
            cur = cur->next;
        }
    } while (cur != NULL);

    return 0;
}
```
''',
'''
```
int main(void) {
    Node *node1 = createNode(1);
    Node *node2 = createNode(2);
    Node *node3 = createNode(3);

    node1->next = node2;
    node2->next = node3;
    
    Node *cur = node1;
    do {
        if (cur != NULL) {
            printf("%d ", cur->data);
            cur = cur->next;
        }
    } while (cur->next != NULL);

    return 0;
}
```
'''
]

explainations = [
    "A is correct. This is the basic way to traverse a linked list.",
    "B is incorrect. The code does not print the last element of the linked list.",
    "C is correct. This is the same as A.",
    "D is incorrect. The code does not print the last element of the linked list."
]