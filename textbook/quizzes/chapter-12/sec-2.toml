[[questions]]

prompt = "Assume that the `APS105` `struct` has been declared correctly with the following members: `int studentNumber`, `char *instructor`, `double averageGrade`. Which of the following access(es) its members by pointer correctly?"

answer = [1, 3]

distractors = [
'''
```
struct APS105 course = {0, "", 0};
struct APS105 *pCourse = &course;
*pCourse.instructor = "Dennis Ritchie";
*pCourse.studentNumber = 60;
*pCourse.averageGrade = 85.0;
```
''',
'''
```
struct APS105 course = {0, "", 0};
struct APS105 *pCourse = &course;
(*pCourse).instructor = "Dennis Ritchie";
(*pCourse).studentNumber = 60;
(*pCourse).averageGrade = 85.0;
```
''',
'''
```
struct APS105 course = {0, "", 0};
struct APS105 *pCourse = &course;
*pCourse->instructor = "Dennis Ritchie";
*pCourse->studentNumber = 60;
*pCourse->averageGrade = 85.0;
```
''',
'''
```
struct APS105 course = {0, "", 0};
struct APS105 *pCourse = &course;
pCourse->instructor = "Dennis Ritchie";
pCourse->studentNumber = 60;
pCourse->averageGrade = 85.0;
```
'''
]

explainations = [
    "A is incorrect. The `.` operator has higher precedence than the `*` operator. For example, `*pCourse.instructor` is equivalent to `*(pCourse.instructor)`, which is incorrect because `pCourse` is a pointer, not a `struct`.",
    "B is correct. This is the basic way to access a member of a `struct` through a pointer.",
    "C is incorrect. The `->` operator has higher precedence than the `*` operator. For example, `*pCourse->instructor` is equivalent to `*(pCourse->instructor)` which is actually a `char` value, not a `char *` value.",
    "D is correct. This is another way to access a member of a `struct` through a pointer."
]

[[questions]]

prompt = "Which of the following is/are correct to dynamically allocate memory for a `struct`?"

answer = [3]

distractors = [
'''
```
#include <stdio.h>

struct Employee {
    char *name;
    int age;
    double salary;
    struct Employee subordinate;
} *pBoss;

int main() {
    pBoss = (struct Employee *)malloc(sizeof(struct Employee));
    &pBoss->subordinate = (struct Employee *)malloc(sizeof(struct Employee));
    pBoss->name = "Boss";
    pBoss->subordinate.name = "Subordinate";
    return 0;
}
```
''',
'''
```
#include <stdio.h>

struct Employee {
    char *name;
    int age;
    double salary;
    struct Employee *subordinate;
} *pBoss;

int main() {
    pBoss = (struct Employee *)malloc(sizeof(struct Employee));
    *pBoss->subordinate = (struct Employee *)malloc(sizeof(struct Employee));
    pBoss->name = "Boss";
    pBoss->subordinate.name = "Subordinate";
    return 0;
}
```
''',
'''
```
#include <stdio.h>

struct Employee {
    char *name;
    int age;
    double salary;
    struct Employee *subordinate;
} *pBoss;

int main() {
    pBoss = (Employee *)malloc(sizeof(Employee));
    pBoss->subordinate = (Employee *)malloc(sizeof(Employee));
    pBoss->name = "Boss";
    pBoss->subordinate->name = "Subordinate";
    return 0;
}
```
''',
'''
```
#include <stdio.h>

struct Employee {
    char *name;
    int age;
    double salary;
    struct Employee *subordinate;
} *pBoss;

int main() {
    pBoss = (struct Employee *)malloc(sizeof(struct Employee));
    pBoss->subordinate = (struct Employee *)malloc(sizeof(struct Employee));
    pBoss->name = "Boss";
    pBoss->subordinate->name = "Subordinate";
    return 0;
}
```
'''
]

explainations = [
    "A is incorrect. The nested `struct` declaration is incorrect. The compiler cannot determine the size of the `struct`.",
    "B is incorrect. The `->` operator has higher precedence than the `*` operator. For example, `*pBoss->subordinate` is equivalent to `*(pBoss->subordinate)` which is actually a `struct Employee` value, not a `struct Employee *` value. Thus, it cannot be assigned to another `struct Employee *` value.",
    "C is incorrect. The `Employee` type is not defined. It should be `struct Employee`.",
    "D is correct. This is the basic way to dynamically allocate memory for a `struct`."
]