let parsedObject; 
  parsedObject = {
  "questions": [
    {
      "prompt": "What is the decimal equivalent of the binary number 10110?",
      "answer": [
        3
      ],
      "distractors": [
        "16",
        "18",
        "20",
        "22"
      ],
      "explainations": [
        "16 is incorrect. Converting binary to decimal involves assigning weights to each bit based on its position and summing them up. In this case, the binary number 10110 can be converted to decimal as follows:\n\n(1 * 2^4) + (0 * 2^3) + (1 * 2^2) + (1 * 2^1) + (0 * 2^0) = 16 + 0 + 4 + 2 + 0 = 22\n\nTherefore, the correct answer is D) 22, which is the decimal equivalent of the binary number 10110.\n",
        "18 is incorrect. Converting binary to decimal involves assigning weights to each bit based on its position and summing them up. In this case, the binary number 10110 can be converted to decimal as follows:\n\n(1 * 2^4) + (0 * 2^3) + (1 * 2^2) + (1 * 2^1) + (0 * 2^0) = 16 + 0 + 4 + 2 + 0 = 22\n\nTherefore, the correct answer is D) 22, which is the decimal equivalent of the binary number 10110.\n",
        "20 is incorrect. Converting binary to decimal involves assigning weights to each bit based on its position and summing them up. In this case, the binary number 10110 can be converted to decimal as follows:\n\n(1 * 2^4) + (0 * 2^3) + (1 * 2^2) + (1 * 2^1) + (0 * 2^0) = 16 + 0 + 4 + 2 + 0 = 22\n\nTherefore, the correct answer is D) 22, which is the decimal equivalent of the binary number 10110.\n",
        "22 is correct. Converting binary to decimal involves assigning weights to each bit based on its position and summing them up. In this case, the binary number 10110 can be converted to decimal as follows:\n\n(1 * 2^4) + (0 * 2^3) + (1 * 2^2) + (1 * 2^1) + (0 * 2^0) = 16 + 0 + 4 + 2 + 0 = 22\n\nTherefore, the correct answer is D) 22, which is the decimal equivalent of the binary number 10110.\n"
      ]
    },
    {
      "prompt": "Convert the decimal number 14 to binary.",
      "answer": [
        2
      ],
      "distractors": [
        "1010",
        "1100",
        "1110",
        "1001"
      ],
      "explainations": [
        "1010 is incorrect. To convert the decimal number 14 to binary, we use a division-based method. We repeatedly divide the decimal number by 2 and note the remainder at each step. The binary equivalent is obtained by reading the remainders in reverse order.\n\nThe steps for converting 14 to binary are as follows:\n\n14 ÷ 2 = 7 remainder 0\n7 ÷ 2 = 3 remainder 1\n3 ÷ 2 = 1 remainder 1\n1 ÷ 2 = 0 remainder 1\n\nReading the remainders in reverse order, we get 1110, which is the binary representation of the decimal number 14.\n",
        "1100 is incorrect. To convert the decimal number 14 to binary, we use a division-based method. We repeatedly divide the decimal number by 2 and note the remainder at each step. The binary equivalent is obtained by reading the remainders in reverse order.\n\nThe steps for converting 14 to binary are as follows:\n\n14 ÷ 2 = 7 remainder 0\n7 ÷ 2 = 3 remainder 1\n3 ÷ 2 = 1 remainder 1\n1 ÷ 2 = 0 remainder 1\n\nReading the remainders in reverse order, we get 1110, which is the binary representation of the decimal number 14.\n",
        "1110 is correct. To convert the decimal number 14 to binary, we use a division-based method. We repeatedly divide the decimal number by 2 and note the remainder at each step. The binary equivalent is obtained by reading the remainders in reverse order.\n\nThe steps for converting 14 to binary are as follows:\n\n14 ÷ 2 = 7 remainder 0\n7 ÷ 2 = 3 remainder 1\n3 ÷ 2 = 1 remainder 1\n1 ÷ 2 = 0 remainder 1\n\nReading the remainders in reverse order, we get 1110, which is the binary representation of the decimal number 14.\n",
        "1001 is incorrect. To convert the decimal number 14 to binary, we use a division-based method. We repeatedly divide the decimal number by 2 and note the remainder at each step. The binary equivalent is obtained by reading the remainders in reverse order.\n\nThe steps for converting 14 to binary are as follows:\n\n14 ÷ 2 = 7 remainder 0\n7 ÷ 2 = 3 remainder 1\n3 ÷ 2 = 1 remainder 1\n1 ÷ 2 = 0 remainder 1\n\nReading the remainders in reverse order, we get 1110, which is the binary representation of the decimal number 14.\n"
      ]
    },
    {
      "prompt": "In computer systems, hexadecimal (hex) is commonly used as a representation of binary values due to its concise nature (as you can see lots of memory addresses are represented in hex). Hexadecimal numbers use base 16, with digits ranging from 0 to 9 and letters A to F representing values 10 to 15. Convert the hexadecimal values 3, A, and 3A to binary. (Hint: convert each digit as decimal value to binary separately, then combine the results)",
      "answer": [
        0
      ],
      "distractors": [
        "0011, 1010, 00111010",
        "0100, 1111, 11000111",
        "1010, 0011, 11011001",
        "1100, 0110, 01001101"
      ],
      "explainations": [
        "The hexadecimal digit 3 is equal to binary 0011.\n\nThe hexadecimal digit A is equal to binary 1010.\n\nThe hexadecimal value 3A can be broken down into 3 and A, which convert to binary as 0011 and 1010, respectively.\n",
        "The hexadecimal digit 3 is equal to binary 0011.\n\nThe hexadecimal digit A is equal to binary 1010.\n\nThe hexadecimal value 3A can be broken down into 3 and A, which convert to binary as 0011 and 1010, respectively.\n",
        "The hexadecimal digit 3 is equal to binary 0011.\n\nThe hexadecimal digit A is equal to binary 1010.\n\nThe hexadecimal value 3A can be broken down into 3 and A, which convert to binary as 0011 and 1010, respectively.\n",
        "The hexadecimal digit 3 is equal to binary 0011.\n\nThe hexadecimal digit A is equal to binary 1010.\n\nThe hexadecimal value 3A can be broken down into 3 and A, which convert to binary as 0011 and 1010, respectively.\n"
      ]
    },
    {
      "prompt": "Let's say you want to design a \"micro\" computer with exactly 64KB of memory. How many bits would you need to address each byte of memory?",
      "answer": [
        3
      ],
      "distractors": [
        "4 bits",
        "8 bits",
        "12 bits",
        "16 bits"
      ],
      "explainations": [
        "4 bits is incorrect. The memory is organized in cells. Each cell stores a byte. Each cell has an address. This makes the memory byte-addressable. This means at each address only one byte is stored.\n\nTo address 64KB of memory, we can use a 16-bit address. This allows us to represent 2^16 = 65,536 unique addresses, which covers the range of 64KB.\n",
        "8 bits is incorrect. The memory is organized in cells. Each cell stores a byte. Each cell has an address. This makes the memory byte-addressable. This means at each address only one byte is stored.\n\nTo address 64KB of memory, we can use a 16-bit address. This allows us to represent 2^16 = 65,536 unique addresses, which covers the range of 64KB.\n",
        "12 bits is incorrect. The memory is organized in cells. Each cell stores a byte. Each cell has an address. This makes the memory byte-addressable. This means at each address only one byte is stored.\n\nTo address 64KB of memory, we can use a 16-bit address. This allows us to represent 2^16 = 65,536 unique addresses, which covers the range of 64KB.\n",
        "16 bits is correct. The memory is organized in cells. Each cell stores a byte. Each cell has an address. This makes the memory byte-addressable. This means at each address only one byte is stored.\n\nTo address 64KB of memory, we can use a 16-bit address. This allows us to represent 2^16 = 65,536 unique addresses, which covers the range of 64KB.\n"
      ]
    }
  ]
};